---
title: "Create Custom Packs"
description: "Create your own custom packs. Pick cards, odds, and risk level with complete transparency for pulls."
---

Transparent Packs revolutionize the traditional pack-opening experience by giving you full visibility into contents, odds, and expected values before you make any purchase decision.

## Custom Pack Creation

### Design Your Own Experience

<CardGroup cols={2}>
  <Card
    title="Card Selection"
    icon="hand-pointer"
  >
    Choose specific cards from our extensive database of authenticated collectibles
  </Card>
  
  <Card
    title="Odds Configuration"
    icon="dice"
  >
    Set custom pull rates and rarity distributions to match your desired risk profile
  </Card>
  
  <Card
    title="Risk Level Tuning"
    icon="gauge-high"
  >
    Adjust expected values and volatility to create anything from safe investments to high-risk, high-reward scenarios
  </Card>
  
  <Card
    title="Theme Creation"
    icon="palette"
  >
    Build themed packs around specific players, sets, eras, or investment strategies
  </Card>
</CardGroup>

### Pack Building Process

#### Step 1: Select Your Cards
Choose the specific cards you want to appear in your pack from our authenticated database.

#### Step 2: Set Your Odds
Pick from random levels to different risk levels using our drag and drop interface. The price adjusts automatically as you modify the odds.

#### Step 3: Open Your Pack
Once you're satisfied with your card selection and odds, open your pack and see what you get!

## What Makes Our Packs Transparent?

### Complete Odds Disclosure
Unlike traditional packs where odds are hidden or vague, every pack you buy or build and buy shows:
- **Exact pull rates** for every possible card or item
- **Real-time optimization system** that ensures fair pack pricing

### Verifiable Randomness
<Tabs>
  <Tab title="Blockchain RNG">
    We use blockchain-based random number generation to ensure true randomness that can be independently verified.
  </Tab>
  
  <Tab title="Audit Trail">
    Every pack opening is recorded with a complete audit trail showing the random seed, algorithm used, and final result.
  </Tab>
  
  <Tab title="Public Verification">
    Anyone can verify the randomness and fairness of any pack opening using our open-source verification tools.
  </Tab>
</Tabs>

### Real-Time Optimization System

Our real-time optimization system continuously monitors live market values and automatically sorts cards into value buckets (P0-P5). A \$45 card in the P1 bucket (\$40-50) moves to P2 (\$50-100) if its price increases, ensuring probability tables always reflect current market reality.

The system uses **[machine learning optimization](https://docs.scipy.org/doc/scipy/reference/optimize.html)** to minimize the difference between expected value and pack price. It heavily penalizes scenarios where expected value is less than price, then iteratively adjusts probabilities until optimal.

Result: Pack probabilities automatically adapt to market conditions while guaranteeing you never pay more than expected value.

Below is the algorithm code we use for pack probability calculations with changed variable names:

```python
# --- PACK CONFIGURATIONS ---
PACK_CONFIGS = {
    'bronze': {
        'bucket_ranges': [
            {'min': 1, 'max': 5},
            {'min': 5.01, 'max': 10},
            {'min': 10.01, 'max': 20},
            {'min': 20.01, 'max': 30},
            {'min': 30.01, 'max': 50},
            {'min': 50.01, 'max': 100},
        ],
        'default_probs': [X, X, X, X, X, X],
    },
    'silver': {
        'bucket_ranges': [
            {'min': 15.00, 'max': 25.00},
            {'min': 25.01, 'max': 50.00},
            {'min': 50.01, 'max': 100.00},
            {'min': 100.01, 'max': 200.00},
            {'min': 200.01, 'max': 400.00},
            {'min': 400.01, 'max': 800.00},
        ],
        'default_probs': [X, X, X, X, X, X],
    },
    # OTHER PACK CONFIGURATIONS
}

# --- GENERIC BUCKET ASSIGNMENT ---
def assign_bucket(market_value, bucket_ranges):
    for i, rng in enumerate(bucket_ranges):
        if rng['min'] <= market_value <= rng['max']:
            return f'bucket{i}'
    return 'no_bucket'

# --- GENERIC BUCKET DATA FETCH ---
def fetch_bucket_data_generic(pack_type):
    print(f"Fetching cards for pack type: {pack_type}")
    config = PACK_CONFIGS[pack_type]
    bucket_ranges = config['bucket_ranges']
    
    # Fetch all cards available for this pack
    response = supabase.table('REDACTED_TABLE_NAME') \
        .select('REDACTED_SEARCH_PARAMETERS') \
        .eq('REDACTED_FILTER', True) \
        .execute()
        
    if not response.data:
        print("No cards available for packs.")
        return create_empty_bucket_data_generic(pack_type), {}, bucket_ranges
        
    cards = response.data
    
    # Assign cards to buckets
    bucket_stats = {}
    bucket_card_ids = {}
    
    for i in range(6):
        bucket_stats[f'bucket{i}'] = {'values': [], 'count': 0, 'cards': []}
        bucket_card_ids[f'P{i}'] = []
        
    bucket_stats['no_bucket'] = {'values': [], 'count': 0, 'cards': []}
    bucket_card_ids['P_NO_BUCKET'] = []
    
    for card in cards:
        value = card.get('market_value') or card.get('price') or 0.0
        bucket = assign_bucket(value, bucket_ranges)
        bucket_stats[bucket]['values'].append(float(value))
        bucket_stats[bucket]['count'] += 1
        bucket_stats[bucket]['cards'].append(card)
        
        if bucket == 'no_bucket':
            bucket_card_ids['P_NO_BUCKET'].append(card['id'])
        else:
            idx = int(bucket.replace('bucket', ''))
            bucket_card_ids[f'P{idx}'].append(card['id'])

def calculate_optimized_probabilities_generic(bucket_data, target_probs, bucket_ranges, target_ev):
    """Calculate optimized probabilities using scipy"""
    import numpy as np
    from scipy.optimize import minimize
    
    avg_values = []
    actual_values_used = []
    
    for i, p_bucket in enumerate(['P0', 'P1', 'P2', 'P3', 'P4', 'P5']):
        bucket_avg = bucket_data[p_bucket]['average_value']
        if bucket_avg > 0:
            value_used = bucket_avg
            actual_values_used.append(f"{value_used} (from {bucket_data[p_bucket]['num_cards']} cards)")
        else:
            rng = bucket_ranges[i]
            value_used = (rng['min'] + rng['max']) / 2
            actual_values_used.append(f"{value_used} (midpoint default)")
        avg_values.append(value_used)
    
    avg_values = np.array(avg_values)
    baseline_ev = np.dot(target_probs, avg_values)
    
    return optimized_probabilities
```

## Start Creating Today

Ready to revolutionize your pack opening experience?

<CardGroup cols={2}>
  <Card
    title="Explore Packs"
    icon="magnifying-glass"
    href="https://catchbackcards.com/packs"
  >
    Browse our marketplace of transparent packs
  </Card>
  
  <Card
    title="Create Pack"
    icon="plus"
    href="https://catchbackcards.com/packs/custom"
  >
    Design your own custom transparent pack
  </Card>
</CardGroup>

---